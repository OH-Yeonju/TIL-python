#### 순서가 없는 데이터 구조

- 셋
  
  중복되는 요소 없이 순서에 상관없는 데이터들의 묶음 (중복시 하나만 저장, 인덱스를 이용한 접근 불가능)
  
  집합 연산이 가능(여집합은 불가능)
  
  가변 자료형 - 순서가 없기 때문에 추가 및 변경시 순서가 바뀔 수 있다
  
  집합 관련 함수 존재(isdisjoint 등)

- 딕셔너리
  
  키 : 변경 불가능한 데이터만 활용 가능 / 값 : 어떤 형태든 상관없음
  
  기본적으로 순서가 없는 자료형임..
  
  .get(k) > 키 k의 값을 반환하는데 키 k가 딕셔너리에 없을 경우 None을 반환
  
  .get(k)과 그냥 dict[k]의 차이 : 후자는 확신을 가지고 있어서 오류가 날 수 있음. get을 쓰는걸 추천
  
  .get(k, v) > 키 k의 값을 반환하는데 키k가 딕셔너리에 없을 경우 v를 반환
  
  뷰? 반복 가능한 객체

#### 얕은 복사와 깊은 복사

- 얕은 복사
  
  =을 사용해 같은 위치의 데이터를 이용함. 값 바뀔 시 같이 바뀜
  
  slice 연산자 활용하여 같은 원소를 가진 리스트지만 연산된 결과를 복사(다른 주소)
  
  import copy
  
  copy.copy() >> 1차원적인 copy를 해주는것
  
  ! 주의
  
  복사하는 리스트의 원소가 주소를 참조하는 경우(ex) a = [1, 2, ['a', 'b'] > 리스트 저장시 a[2]의 위치에 주소를 저장하고 리스트가 저장된 곳을 찾아감, 원본 복사시 주소를 복사하는거기때문에 주소의 내용 바꿀 시 원본도 바뀌게 됨)

- 깊은 복사
  
  같은 데이터를 다른 위치에 저장. 서로 다르게 이용 가능.
  
  리스트(주소를 참조하는 데이터)를 포함하는 데이터 복사시
  
  import copy
  
  copy.deepcopy() 사용





#### 기억하기 좋은...

import collection 사용시 **counter** 객체 중

- .most_common([n])
  
  가장 흔한 요소와 그 개수를 가장 흔한 것부터 가장 적은 순으로 나열한 리스트를 반환합니다. 개수가 같은 요소는 처음 발견된 순서를 유지합니다.

- .subtract([iterable-or-mapping])
  
  이터러블이나 다른 매핑으로부터 온 요소들을 뺍니다. 교체하는 대신 개수를 빼는 것. 입력과 출력 모두 0이나 음수일 수 있음.
